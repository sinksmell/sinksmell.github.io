---
title: "计算机网络基础"
draft: false
description: "学习计算机网络知识可以更好地理解应用之间的网络通信"
tags: [ "network", "tcp", "http"]
lastmod: 2020-01-25
date: "2019-10-14"
categories:
  - "Network"
  - "TCP"
  - "HTTP"
---


### TCP/IP 四层结构

![](https://i.loli.net/2019/03/19/5c90c93369306.png)
ps: 上图中是图解HTTP中的划分
* 应用层
> 决定了向用户提供应用服务时通信的活动

* 传输层
> 提供处于网络连接中的两台计算机直接的数据传输

* 网络层 或 网际层
> 处理网络上流动的数据包

* 网络接口层 对应 OSI 中的 链路层+物理层
> 处理连接网络的硬件部分



### 应用层

#### HTTP协议

* HTTP请求报文格式

![](https://i.loli.net/2019/03/19/5c90c93131e1d.png)


* HTTP响应报文格式

![](https://i.loli.net/2019/03/19/5c90c93268f14.png)

**GET请求与POST请求的区别?**
> * GET请求参数出现在url中，POST请求数据写入报文主体
> * GET请求封装在一个TCP报文中发出，POST 被浏览器拆分，先发首部，再发数据
> * GET请求时幂等的，POST不是

### 传输层

#### TCP

* TCP 连接的建立
![](https://i.loli.net/2019/03/19/5c90c934694ab.png)

三次握手过程(三握手报文)及目的
> 目的：建立可靠的通信信道,简单地说，就是通信双方都确认自己与对方的接收与发送都是正常的。

| 序号|方向| 动作 | 效果|
|:--:| :--:| :--:| :--:|
| 1|Client -> Sever| 发送带有*SYN*标志的数据包| Server确定自己接收正常；对方发送正常|
|2 | Server -> Client |发送带有*SYN*和*ACK*标志的数据包|Client确定自己发送正常,接收正常；对方发送正常|
|3 | Client -> Server | 发送带有*ACK*标志的数据包|Server确认自己发送正常,接收正常；对方发送正常,接收正常|

**为什么要进行3次握手?**
> * 防止之前的请求建立连接报文滞留网络中，当报文到达Server端是2，对报文确认，此时会打开2条连接。第三次握手的存在可以使客户端忽略服务端对滞留报文的确认。
> * 通过3次握手，双方才能初始化通信时的序号seq和ack，即ISN（Intial Sequence Number）和 MSS
> * 通过次握手，通信双方才能知道自己和对方 发送和接收功能都正常

**Question:有没有其它握手方案?**
> * 可以将第二次握手 Server -> Client 发送*SYN*,*ACK* 报文拆分成两次 一次发送 *SYN* 一次发送*ACK*
> * 三次握手已经是最佳方案,握手次数不能比3少,可以比3多,但握手次数多消耗资源也更多

* TCP 连接的释放
![](https://i.loli.net/2019/03/19/5c90c93569f64.png)

四次挥手
> 对可靠的通信信道进行关闭

| 序号|方向| 动作 | 效果|
|:--:| :--:| :--:| :--:|
| 1 |Client -> Server| 发送带有*FIN*的数据包| Client提出关闭请求,进入只接收不发送状态 |
| 2 |Server -> Client| 发送带有*ACK*的数据包| Server回应收到关闭请求|
| 3 |Server -> Client| 发送带有*FIN*的数据包| Server提出关闭请求|
| 4 |Client -> Server| 发送带有*ACK*的数据包| Client发送最后一个*ACK* 通道关闭|

**为什么要进行四次挥手?**
> * TCP连接是全双工的，双方都要主动关闭连接和确认对方关闭
> * 如果两边同时断开连接，就会进入CLOSING状态，然后到达TIME_WAIT状态，双方都会浪费2MSL时间
> * ps: RFC793 3.5节中提到，如果Server收到FIN后没有数据要发送了，那么就回复一个FIN，ACK 四次握手就变成了3次，(多次出现[ F.]、[F.]、[.]三个序列，即3次挥手）
![](https://i.loli.net/2019/08/15/H4lByPZmhUANJpW.png)

**TIME-WAIT 为何等待2MSL？**
> ps: MSL 为最长报文寿命
> 
> * 1. 保证最后一个ACK被服务端收到,没收到可以再发送,并重置2MSL定时器
> * 2. 保证本地端口号在2MSL时间内*不会*被再次使用,避免新连接中出现旧连接的请求报文

**如何避免TIME_WAIT**
> * 调整Linux内核参数
>> * 修改/etc/sysctl.conf 设置 net.ipv4.tcp_tw_reuse = 1 复用TIME_WAIT状态下的socket
>> * net.ipv4.tcp_tw_recycle = 1 加速TIME_WAIT状态下的socket回收
> * 设置Nginx等服务器
> > * 设置keepalive 属性 让服务器不要主动关闭连接，除非连接超时
> * 使用RST报文来关闭连接
>>* RST表示复位，用来异常的关闭连接，在TCP的设计中它是不可或缺的。就像上面说的一样，发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送RST包。而接收端收到RST包后，也不必发送ACK包来确认。
> * 设置socket属性：SO_REUSEADDR
> > * 这个套接字选项通知内核，如果端口忙，但TCP状态位于 TIME_WAIT ，可以重用 端口。如果端口忙，而TCP状态位于其他状态，重用端口时依旧得到一个错误信息， 指明"地址已经使用中"。如果你的服务程序停止后想立即重启，而新套接字依旧 使用同一端口，此时 SO_REUSEADDR 选项非常有用。必须意识到，此时任何非期 望数据到达，都可能导致服务程序反应混乱，不过这只是一种可能，事实上很不 可能。

**CLOSE-WAIT 存在意义?**
> 通知上层应用,通道即将关闭，尽快把剩余的数据发出，上层应用将剩余数据发送完成后，确认关闭后，Server才发出 *FIN* 报文


**TCP提供可靠传输服务的原因**

* **可靠传输的工作原理**

1.停止等待协议
> 每发送完一个分组就停下来,等待对方的确认,收到确认后再发送下一个分组

2.连续ARQ协议
> 发送方每收到一个确认就把发送窗口向前移动一个分组的位置

* **可靠传输的实现**

1.`滑动窗口协议`

2.超时重传机制

#### UDP



### 网络层


### 链路层

