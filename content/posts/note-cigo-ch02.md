---
title: "Concurrency in Go 读书笔记 第二章"
date: 2020-02-05T13:24:47+08:00
draft: true
tags:
    - "concurrency in go"
    - "chapter1"
categories:
    - "读书笔记"
---

## 代码建模: CSP

### 并发与并行

> * 教科书上的定义，并发指的是某一时间段内多个任务同时进行，并行指的是某一时刻，多个任务同时进行
>
> * 本书中的定义很独特 `Concurrency is a property of the code;parallelism is a property of the running program`
>
>   > `并发是代码的属性，并行是运行的程序的属性`
>   >
>   > * 1. 编码角度。当你在编写代码时，可以使用多线程或其他方式，使得某些任务可以同时进行。但是，考虑一下，你只编写了并发的代码。
>   > * 2. 运行角度。假设你的程序编写的两个线程可以同时执行，但是 cpu 是单核的。程序一执行，操作系统中就多了一个进程，该进程中的两个线程，并不能同一时刻执行，他们只能构成并发。如果 CPU 是两核或者是单核两线程，那么该进程中的两个线程，可能被调度到不同的核心上执行，从而构成并行。
>   > * 3. 并行与时间。并行是一个时间的函数，或者说是上下文（context）。举个例子，我们有一个 context，时间是5s,有两个操作待执行，每个操作是 2 s,此时两个任务可以并行执行。如果 context 时间是 1 s,那么两个任务只能是串行。 `context is defined as the bounds by which two or more operations could be considered parallel` , 这里作者就是想通过时间片长度来说明并行。
>   > * 总结，是并发还是并行，除了程序本身的多线程技术，还要考虑 **runtime**， OS,CPU等 的情况。

### Context

> 译作上下文，可指代的内容广泛。
>
> > 一个进程，系统线程，机器等都可以描述为上下文。正如原子操作的定义依赖上下文，并发操作的正确性也依赖上下文。

#### 上下文举例

> 逐渐降低抽象级别
> 1. 进程级别。假设你的电脑上有一个计算器的程序，你点击他，程序启动了。此时，你的电脑就是这个计算器进程的上下文。
>
>    > ps 根据操作系统的知识，进程有独立性的性质，再启动一个计算器程序，两个进程之间相互独立。
>
> 2. 线程级别。假设该计算器进程能被多个用户同时访问。此时就需要考虑，竞态，死锁，活锁，饥饿等问题，因为多个线程共享一个进程的资源，处于同一上下文内。
>
> 3. 函数调用栈级别。此时问题变得异常复杂，但越底层，越复杂，对并发影响越大。还好大部分并发逻辑都是在线程级别编写的。

### 经典并发模型

> * go出现之前，大多数编程语言都是基于线程级别，加上同步内存访问实现的并发
> * 由于频繁创建和释放线程开销较大，出现了线程池的技术

### Go并发模型

> * 使用 goroutine 代替 thread
>
> * 基于 Communicating Seauential Processes 论文 ，实现了 channel + goroutine 的并发模型
>
>   > * goroutine 可以看做是协程的一种，也就是用户级线程，运行与于用户态。其他语言中的线程，是系统级线程，运行于内核态，使用 ps ，top 之类的工具可以看到的线程。上下文切换时触发中断，使 cpu 进入内核态，也被成为内核级线程。
>   >
>   > * Channel 类似传统的 FIFO,命名管道，可在 goroutine 直接进行通信，并发安全。



### CSP简介

